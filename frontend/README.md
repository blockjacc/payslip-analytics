# frontend

## Project setup
```
yarn install
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).

# Charting Standards for Payslip Analytics App

## Stacked Bar Chart Logic (Payslip Analytics)

### 1. Chart Structure
- **Type:** Vertical stacked bar chart (Chart.js Bar with `stacked: true`)
- **X-Axis:**
  - Aggregate/single-period: one label, e.g., 'Total'
  - Separate/multi-period: one label per period (e.g., 'March 3, 2025 - March 17, 2025')
- **Y-Axis:**
  - **Type:** Linear (with logarithmically-spaced custom tick values)
  - **Start:** Always at 0
  - **First Tick Above 0:** Smallest non-zero value among all selected fields
  - **Top Tick:** Total sum of all values (for aggregate) or max period sum (for separate)
  - **Ticks:** Exactly 11 ticks total: [0, min, then 9 logarithmic steps to total sum]
  - **Tick Generation:** Custom `getSimpleYAxis` utility in `src/utils/chartAxis.js`
  - **Tick Implementation:** Linear scale with `stepSize: max/10`, `count: 11`, and callback mapping
  - **No Chart.js auto-ticks**—our exact values are enforced via callback mapping
- **Bar Segments:**
  - Each selected field is a segment in the stack
  - All selected fields are always included, even if value is zero
  - **Segments are always stacked from lowest value (bottom) to highest (top)**
- **Legend:** Always displayed on the right
- **Font:** 'Open Sans' for all chart text

### 2. Technical Implementation

#### Y-Axis Tick Logic (`src/utils/chartAxis.js`)
```javascript
// Utility function generates 11 logarithmic ticks
export function getSimpleYAxis(values) {
  const nonZero = values.filter(v => v > 0);
  const min = Math.min(...nonZero);
  const totalSum = nonZero.reduce((sum, v) => sum + v, 0);
  
  // 11 ticks: 0, min, then 9 more logarithmic steps to totalSum
  const ticks = [0, min];
  for (let i = 1; i <= 9; i++) {
    const t = min * Math.pow(totalSum / min, i / 9);
    ticks.push(Math.round(t));
  }
  ticks[10] = totalSum; // Ensure last tick is exactly the total sum
  
  return { min: 0, max: totalSum, ticks };
}
```

#### Chart Configuration
```javascript
import { getSimpleYAxis } from '../utils/chartAxis';

// In chartOptions computed property:
const { min, max, ticks } = getSimpleYAxis(values);

scales: {
  y: {
    type: 'linear',
    min: 0,
    max: max,
    ticks: {
      stepSize: max / 10,
      count: 11,
      callback: function(value, index, values) {
        // Map Chart.js tick positions to our exact values
        if (index < ticks.length) {
          return ticks[index].toLocaleString('en-US');
        }
        return '';
      }
    }
  }
}
```

### 3. Data Handling
- **Aggregate View:**
  - Treat as a single-period 'separate' case for charting logic
  - All selected fields are stacked in one bar
  - Values array: all field values for the period
- **Separate View:**
  - Each period is a bar, fields are stacked segments
  - Values array: all field values across all periods
- **Field Names:**
  - Must match between backend and frontend
  - All selected fields must be present in the chart, even if value is zero

### 4. UI/UX Consistency
- **Button Styling:** Consistent with payslip pattern
- **Card Layout:** Consistent with payslip pattern
- **Routing:** Unified pattern for all analytics

### 5. Implementation Checklist
- [ ] Chart uses linear scale with custom logarithmic tick values
- [ ] Y-axis starts at 0, first tick is smallest value, top is total sum
- [ ] Exactly 11 ticks generated by `getSimpleYAxis` utility
- [ ] Tick callback maps Chart.js positions to our exact values
- [ ] All selected fields are always shown as segments
- [ ] Legend is on the right
- [ ] Font is 'Open Sans' everywhere
- [ ] Chart logic is unified for aggregate and separate

### 6. Example Implementation (Payslip)
- **Values:** [1157.92, 2077, 39.01]
- **Generated Ticks:** [0, 39, 64, 104, 171, 279, 457, 748, 1223, 2001, 3274]
- **Chart Display:** 11 evenly-spaced ticks with logarithmic values
- **Bar Segments:** Absent (39.01), Regular (2077), Overtime (1157.92) - stacked

### 7. Example Implementation (Shifts)
- **Values:** [148, 7, 1, 1, 1] (schedule type counts)
- **Generated Ticks:** [0, 1, 2, 3, 5, 9, 17, 29, 51, 90, 158]
- **Chart Display:** 11 evenly-spaced ticks with logarithmic values
- **Bar Segments:** Open Shift (1), Rest Day (1), Workshift (1), Flexible Hours (7), Uniform Working Days (148) - stacked

### Key Technical Notes
1. **Linear vs Logarithmic Scale:** We use linear scale with logarithmically-spaced tick values because Chart.js logarithmic scale doesn't reliably respect custom tick arrays.
2. **Tick Enforcement:** The `callback` function maps Chart.js-generated tick positions to our exact logarithmic values.
3. **Unified Chart Utilities:** All charts use unified utilities for consistent behavior:
   - `getUnifiedStackedBarChart()` for simple single-value charts (shifts)
   - `getUnifiedPayslipChart()` for multi-period, multi-field charts (payslip)
4. **Consistent Stacking:** All charts automatically sort data from lowest to highest values for proper stacking order.
5. **No afterBuildTicks:** Chart.js callbacks like `afterBuildTicks` are unreliable; we use the tick callback approach instead.

---

**This documentation is the predicate for all charting in this app. Any new chart or analytics view must follow these standards for consistency, clarity, and maintainability.**

## Drilldown Data Handling (Payslip Analytics)

### Principle
- The backend always returns period-separated employee records (one record per employee per period).
- The frontend is responsible for all further computation and aggregation, in memory.

### Drilldown Views
- **Separate Drilldown:**
  - The frontend displays the data as structured in memory: one row per employee per period.
  - The user can select a period to view the breakdown for that period only.
- **Aggregate Drilldown:**
  - The frontend groups all employee records by `emp_id` and sums all numeric fields across all periods.
  - Only one row per employee is displayed, with totals for each field for the full period.
  - The CSV export for aggregate drilldown also uses these in-memory totals.

### Rationale
- This approach keeps the backend simple and stateless.
- All analytics, aggregation, and drilldown logic is centralized in the frontend, making it easy to adapt and extend.
- This is fully consistent with the in-memory compute principle described in `inmemorycompute.txt`.

---

## In-Memory Compute Principle (All Analytics & Drilldowns)

### Principle
- **Single Fetch:** The backend retrieves and decrypts all relevant records for a user's analytics/drilldown request in one query.
- **No Backend Specialization:** The backend does not implement separate endpoints or logic for each visualization, aggregation, or drilldown type.
- **In-Memory Processing:** All further computation—aggregation, grouping, filtering, drilldown, and transformation—is performed in memory (in the frontend or backend session), not in the database or via additional backend endpoints.

### Application
- **Analytics Views:** The frontend receives all necessary raw records and computes totals, groupings, and visualizations as needed.
- **Drilldowns:** The frontend (or in-memory backend logic) can group, sum, or filter records for any drilldown or export, without requiring new backend code.
- **CSV/Export:** Any export reflects the current in-memory view, not a new backend query.

### Rationale
- **Performance:** Minimizes database I/O and backend load by fetching once per request.
- **Flexibility:** Enables new visualizations, aggregations, and drilldowns without backend changes.
- **Maintainability:** Keeps backend simple, stateless, and focused on secure data retrieval and decryption.

### Example
- For payslip analytics, the backend returns all payslip records for the selected period(s). The frontend computes both aggregate and per-period views, as well as employee-level drilldowns, entirely in memory.

---

**This principle applies to all analytics and drilldown features in this app. Any new visualization or export should be implemented using in-memory compute, not new backend endpoints.**

## UI / UX Guidelines

- **Date Picker:**
  - The project uses [`vue-datepicker-next`](https://github.com/mengxiong10/vue-datepicker-next) as the standard date picker component.
  - All date selection in the app should use this component for consistency, accessibility, and cross-browser reliability.
  - Usage example:
    ```vue
    <DatePicker v-model:value="selectedDate" type="date" format="YYYY-MM-DD" value-type="format" :editable="false" />
    ```
  - Import in your component:
    ```js
    import DatePicker from 'vue-datepicker-next';
    import 'vue-datepicker-next/index.css';
    ```
  - See `DeepDive.vue` for a reference implementation.
